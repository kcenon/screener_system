# [BE-006] WebSocket Real-time Price Streaming

## Metadata
- **Status**: IN_PROGRESS
- **Priority**: High
- **Assignee**: AI Assistant
- **Estimated Time**: 16 hours (4h completed, 12h remaining)
- **Sprint**: Sprint 3 (Week 5-6)
- **Tags**: #backend #websocket #real-time #streaming
- **Created**: 2025-11-10
- **Moved to TODO**: 2025-11-10
- **Started**: 2025-11-10 20:00

## Description
Implement WebSocket server for real-time stock price streaming to frontend clients. Enable sub-100ms latency updates for better user experience compared to REST API polling.

## Subtasks
- [x] WebSocket Server Implementation ✅ (Phase 1)
  - [x] FastAPI WebSocket endpoint
  - [x] Connection management (connect, disconnect)
  - [x] Heartbeat/ping-pong mechanism
  - [ ] Automatic reconnection handling (Client-side, Phase 3)
  - [x] Connection pool management
- [x] Room-based Subscription System ✅ (Phase 1)
  - [x] Subscribe to specific stock codes
  - [x] Subscribe to market (KOSPI, KOSDAQ)
  - [x] Subscribe to sector
  - [x] Unsubscribe mechanism
  - [x] Multiple subscriptions per connection
- [ ] Redis Pub/Sub Integration (Phase 2)
  - [ ] Pub/Sub for multi-instance support
  - [ ] Message broadcasting
  - [ ] Channel naming convention
  - [ ] Message serialization (JSON)
- [ ] Data Publishing (Phase 2)
  - [ ] Price update publisher
  - [ ] Order book update publisher
  - [ ] Market status events
  - [ ] Alert notifications
- [x] Message Format ✅ (Phase 1)
  - [x] Event types (price_update, orderbook_update, alert, error)
  - [x] Timestamp in all messages
  - [x] Sequence number for ordering
  - [x] JSON schema validation
- [x] Authentication ✅ (Phase 1 - Basic)
  - [x] JWT token in WebSocket handshake
  - [x] Token validation on connect
  - [ ] Re-authentication on token expiry (Phase 3)
  - [x] Graceful connection closure
- [x] Error Handling ✅ (Phase 1 - Basic)
  - [x] Connection timeout (30 seconds idle)
  - [x] Invalid message handling
  - [x] Subscription errors
  - [ ] Automatic fallback to REST (Phase 3)
- [ ] Performance Optimization (Phase 4)
  - [ ] Message batching (10-50ms window)
  - [ ] Compression (per-message deflate)
  - [ ] Rate limiting per connection
  - [ ] Memory-efficient broadcast

## Acceptance Criteria
- [ ] **Connection Management**
  - [ ] Clients can connect via WebSocket
  - [ ] JWT authentication works
  - [ ] Heartbeat keeps connection alive
  - [ ] Graceful disconnect on client close
- [ ] **Subscription**
  - [ ] Subscribe to stock code (e.g., "005930")
  - [ ] Subscribe to multiple stocks
  - [ ] Unsubscribe works correctly
  - [ ] Only receive subscribed updates
- [ ] **Real-time Updates**
  - [ ] Price updates sent < 100ms after change
  - [ ] Order book updates in real-time
  - [ ] No message loss (99.9% delivery)
  - [ ] Messages arrive in correct order
- [ ] **Performance**
  - [ ] Supports 10,000 concurrent connections
  - [ ] Latency < 100ms (p99)
  - [ ] CPU usage < 50% at peak
  - [ ] Memory < 1GB for 10K connections
- [ ] **Reliability**
  - [ ] 99.9% uptime
  - [ ] Automatic reconnection works
  - [ ] Redis Pub/Sub handles multi-instance
  - [ ] No memory leaks (24+ hour stress test)
- [ ] **Testing**
  - [ ] Unit tests for message handling
  - [ ] Integration tests with Redis
  - [ ] Load testing (10K connections)
  - [ ] Reconnection scenarios tested

## Dependencies
- **Depends on**: BE-001, BE-003, DP-004, INFRA-001
- **Blocks**: FE-005, FE-006

## References
- **SDS.md**: Section 5.4 WebSocket Architecture (to be added)
- **SRS.md**: REQ-PERF-002 Real-time Updates (to be added)
- [FastAPI WebSocket](https://fastapi.tiangolo.com/advanced/websockets/)
- [Redis Pub/Sub](https://redis.io/topics/pubsub)

## Progress
- **25%** - Phase 1 Complete (4h/16h)

### Completed Work

**Phase 1: WebSocket Server Basic Structure (Commit 86f04f3)**
- ✅ Message schemas with type definitions
  - MessageType enum (subscribe, unsubscribe, price_update, orderbook_update, etc.)
  - Request/Response base classes
  - Specific message types (Subscribe, Unsubscribe, PriceUpdate, OrderBookUpdate, etc.)
  - Pydantic validation for all messages
- ✅ Connection Manager (420+ lines)
  - Connection lifecycle (connect, disconnect)
  - Subscription management (subscribe, unsubscribe)
  - Message routing (unicast, multicast, broadcast)
  - Heartbeat mechanism (30-second interval)
  - Statistics tracking
- ✅ WebSocket Endpoint (280+ lines)
  - FastAPI WebSocket route (/v1/ws)
  - Message handling loop
  - Subscribe/Unsubscribe handlers
  - Ping/Pong support
  - Error handling with detailed messages
  - Statistics endpoints (/v1/ws/stats, /v1/ws/connections)
- ✅ Basic Authentication
  - JWT token validation (optional)
  - User ID extraction from token
  - Anonymous connection support
- ✅ Test Suite (270+ lines, 14 test cases)
  - Connection lifecycle tests
  - Message handling tests
  - Subscription tests
  - Error handling tests
  - Connection manager unit tests

**Files Created:**
- `backend/app/schemas/websocket.py` (250+ lines)
- `backend/app/core/websocket.py` (420+ lines)
- `backend/app/api/v1/endpoints/websocket.py` (280+ lines)
- `backend/tests/api/test_websocket.py` (270+ lines)

**Files Modified:**
- `backend/app/main.py` - Added WebSocket router

**Features Implemented:**
- WebSocket connection/disconnection
- Subscription to stock codes, markets, sectors
- Ping/Pong heartbeat
- Error messages with codes and details
- Connection statistics
- Message sequence numbering

### Remaining Work

**Phase 2: Redis Pub/Sub Integration (~4h)**
- Implement Redis publisher/subscriber
- Multi-instance broadcasting
- Channel naming strategy
- Data publisher service

**Phase 3: Enhanced Auth & Error Handling (~4h)**
- Token refresh mechanism
- Automatic fallback to REST
- Client reconnection handling
- Advanced error recovery

**Phase 4: Performance & Testing (~4h)**
- Message batching
- Compression (per-message deflate)
- Rate limiting per connection
- Load testing (10K connections)
- Integration tests with real data

## Notes
- WebSocket protocol allows bi-directional communication
- Use Server-Sent Events (SSE) as simpler alternative if WebSocket too complex
- Consider using socket.io library for easier client management
- Implement exponential backoff for reconnection attempts
- Monitor connection count and close idle connections
- Log all connection events for debugging
- Provide WebSocket testing tool/dashboard
